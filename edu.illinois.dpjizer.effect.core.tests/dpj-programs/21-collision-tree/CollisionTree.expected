com.jme.bounding.BoundingBox.<>BoundingBox(com.jme.math.Vector3f<Rc>,float,float,float) writes R invokes com.jme.bounding.BoundingVolume.BoundingVolume() where { R -> R }, com.jme.math.Vector3f.<>set(com.jme.math.Vector3f<Rvect>) where { this -> R : *, R -> R, Rvect -> Rc }
com.jme.bounding.BoundingBox.<>computeFromTris(int[]<Rindices>,com.jme.scene.TriMesh<Rindices>,int,int) reads Rindices, Root writes R invokes com.jme.bounding.BoundingBox.checkMinMax(com.jme.math.Vector3f<Root>,com.jme.math.Vector3f<Root>,com.jme.math.Vector3f<Root>) where { R -> R }, com.jme.math.Vector3f.<>addLocal(com.jme.math.Vector3f<Rvec>) where { this -> Root : *, R -> Root, Rvec -> Root }, com.jme.math.Vector3f.<>set(com.jme.math.Vector3f<Rvect>) where { this -> R : *, R -> R, Rvect -> Root }, com.jme.math.Vector3f.multLocal(float) where { this -> R : *, R -> R }, com.jme.scene.TriMesh.<>getTriangle(int,com.jme.math.Vector3f<R>[]<R>) where { this -> Rindices : *, RMesh -> Rindices, R -> Root } overrides com.jme.bounding.BoundingVolume.<>computeFromTris(int[]<Rindices>,com.jme.scene.TriMesh<Rindices>,int,int) where { R -> R, Rindices -> Rindices }
com.jme.bounding.BoundingBox.<>intersectsBoundingBox(com.jme.bounding.BoundingBox<Rbb>) reads R, Rbb invokes com.jme.math.Vector3f.<>isValidVector(com.jme.math.Vector3f<Rvector>) where { this -> Root : *, R -> Root, Rvector -> R }, com.jme.math.Vector3f.<>isValidVector(com.jme.math.Vector3f<Rvector>) where { this -> Root : *, R -> Root, Rvector -> Rbb } overrides com.jme.bounding.BoundingVolume.<>intersectsBoundingBox(com.jme.bounding.BoundingBox<Rbb>) where { R -> R, Rbb -> Rbb }
com.jme.bounding.BoundingBox.<>transform_r(com.jme.math.Quaternion<Rrotate>,com.jme.math.Vector3f<Rtranslate>,com.jme.math.Vector3f<Rscale>,com.jme.bounding.BoundingBox<Rstore>,com.jme.math.Matrix3f<RTemp1>,com.jme.math.Vector3f<RTemp2>,com.jme.math.Vector3f<RTemp3>) reads R, RTemp3, Rscale writes RTemp1, Rstore invokes com.jme.math.Matrix3f.<>mult(com.jme.math.Vector3f<Rvec>,com.jme.math.Vector3f<Rproduct>) where { this -> RTemp1 : *, R -> RTemp1, Rvec -> RTemp2, Rproduct -> RTemp3 }, com.jme.math.Matrix3f.<>set(com.jme.math.Quaternion<Rquaternion>) where { this -> RTemp1 : *, R -> RTemp1, Rquaternion -> Rrotate }, com.jme.math.Quaternion.<>mult(com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rstore>) where { this -> Rrotate : *, R -> Rrotate, Rv -> Rstore, Rstore -> Rstore }, com.jme.math.Vector3f.<>addLocal(com.jme.math.Vector3f<Rvec>) where { this -> Rstore : *, R -> Rstore, Rvec -> Rtranslate }, com.jme.math.Vector3f.<>mult(com.jme.math.Vector3f<Rvec>,com.jme.math.Vector3f<Rstore>) where { this -> R : *, R -> R, Rvec -> Rscale, Rstore -> Rstore }, com.jme.math.Vector3f.set(float,float,float) where { this -> RTemp2 : *, R -> RTemp2 }, java.lang.Math.abs(float) where { this -> Root : * } overrides com.jme.bounding.BoundingVolume.<>transform_r(com.jme.math.Quaternion<Rrotate>,com.jme.math.Vector3f<Rtranslate>,com.jme.math.Vector3f<Rscale>,com.jme.bounding.BoundingBox<Rstore>,com.jme.math.Matrix3f<RTemp1>,com.jme.math.Vector3f<RTemp2>,com.jme.math.Vector3f<RTemp3>) where { R -> R, Rrotate -> Rrotate, Rtranslate -> Rtranslate, Rscale -> Rscale, Rstore -> Rstore, RTemp1 -> RTemp1, RTemp2 -> RTemp2, RTemp3 -> RTemp3 }
com.jme.bounding.BoundingBox.BoundingBox() invokes com.jme.bounding.BoundingVolume.BoundingVolume() where { R -> R }
com.jme.bounding.BoundingBox.BoundingBox(com.jme.bounding.BoundingBox<Root : *>) reads Root : * writes R invokes com.jme.bounding.BoundingVolume.BoundingVolume() where { R -> R }
com.jme.bounding.BoundingBox.checkMinMax(com.jme.math.Vector3f<Root>,com.jme.math.Vector3f<Root>,com.jme.math.Vector3f<Root>) writes Root
com.jme.bounding.BoundingVolume.<>computeFromTris(int[]<Rindices>,com.jme.scene.TriMesh<Rindices>,int,int) pure
com.jme.bounding.BoundingVolume.<>intersectsBoundingBox(com.jme.bounding.BoundingBox<Rbb>) pure
com.jme.bounding.BoundingVolume.<>transform_r(com.jme.math.Quaternion<Rrotate>,com.jme.math.Vector3f<Rtranslate>,com.jme.math.Vector3f<Rscale>,com.jme.bounding.BoundingBox<Rstore>,com.jme.math.Matrix3f<RTemp1>,com.jme.math.Vector3f<RTemp2>,com.jme.math.Vector3f<RTemp3>) pure
com.jme.bounding.BoundingVolume.BoundingVolume() invokes java.lang.Object.Object()
com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,R_cT>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,int) reads R, RMesh invokes com.jme.bounding.BoundingVolume.<>transform_r(com.jme.math.Quaternion<Rrotate>,com.jme.math.Vector3f<Rtranslate>,com.jme.math.Vector3f<Rscale>,com.jme.bounding.BoundingBox<Rstore>,com.jme.math.Matrix3f<RTemp1>,com.jme.math.Vector3f<RTemp2>,com.jme.math.Vector3f<RTemp3>) where { this -> R : *, R -> R, Rrotate -> RMesh, Rtranslate -> RMesh, Rscale -> RMesh, Rstore -> Local : *, RTemp1 -> Local : *, RTemp2 -> Local : *, RTemp3 -> Local : * }, com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) where { R -> R, RMesh -> RMesh, R_cT -> R_cT, RctMesh -> R_cT, RTemps -> Local : *, RLists -> RLists, Rwb -> Local : * }, com.jme.scene.TriMesh.getWorldRotation() where { this -> RMesh : *, RMesh -> RMesh }, com.jme.scene.TriMesh.getWorldScale() where { this -> RMesh : *, RMesh -> RMesh }, com.jme.scene.TriMesh.getWorldTranslation() where { this -> RMesh : *, RMesh -> RMesh }
com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) reads R, R : com.jme.bounding.CollisionTree.Left, R : com.jme.bounding.CollisionTree.Right, RMesh, RTemps, R_cT, R_cT : com.jme.bounding.CollisionTree.Left, R_cT : com.jme.bounding.CollisionTree.Right, RctMesh invokes com.jme.bounding.BoundingVolume.<>transform_r(com.jme.math.Quaternion<Rrotate>,com.jme.math.Vector3f<Rtranslate>,com.jme.math.Vector3f<Rscale>,com.jme.bounding.BoundingBox<Rstore>,com.jme.math.Matrix3f<RTemp1>,com.jme.math.Vector3f<RTemp2>,com.jme.math.Vector3f<RTemp3>) where { this -> R_cT : *, R -> R_cT, Rrotate -> RctMesh, Rtranslate -> RctMesh, Rscale -> RctMesh, Rstore -> Local : *, RTemp1 -> RTemps, RTemp2 -> RTemps, RTemp3 -> RTemps }, com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) where { R -> R, RMesh -> RMesh, R_cT -> R_cT : com.jme.bounding.CollisionTree.Left, RctMesh -> RctMesh, RTemps -> RTemps, RLists -> RLists, Rwb -> Rwb }, com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) where { R -> R, RMesh -> RMesh, R_cT -> R_cT : com.jme.bounding.CollisionTree.Right, RctMesh -> RctMesh, RTemps -> Local : *, RLists -> Local : *, Rwb -> Rwb }, com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) where { R -> R, RMesh -> RMesh, R_cT -> R_cT : com.jme.bounding.CollisionTree.Right, RctMesh -> RctMesh, RTemps -> RTemps, RLists -> RLists, Rwb -> Rwb }, com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) where { this -> R_cT : *, R -> R_cT, RMesh -> RctMesh, R_cT -> R : com.jme.bounding.CollisionTree.Left, RctMesh -> RMesh, RTemps -> RTemps, RLists -> RLists, Rwb -> Local : * }, com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) where { this -> R_cT : *, R -> R_cT, RMesh -> RctMesh, R_cT -> R : com.jme.bounding.CollisionTree.Right, RctMesh -> RMesh, RTemps -> Local : *, RLists -> Local : *, Rwb -> Local : * }, com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,RctMesh>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,com.jme.bounding.BoundingVolume<Rwb>,int,com.jme.math.Matrix3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>) where { this -> R_cT : *, R -> R_cT, RMesh -> RctMesh, R_cT -> R : com.jme.bounding.CollisionTree.Right, RctMesh -> RMesh, RTemps -> RTemps, RLists -> RLists, Rwb -> Local : * }, com.jme.bounding.CollisionTree.<>intersectsBounding_r(com.jme.bounding.BoundingVolume<R1>,com.jme.bounding.BoundingVolume<R2>) where { R -> R, RMesh -> RMesh, R1 -> Rwb, R2 -> Local : * }, com.jme.intersection.Intersection.<>intersection_r(com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,float[]<RTemps>,float[]<RTemps>) where { this -> Root : *, RVals -> RTemps, RTemps -> RTemps }, com.jme.math.Quaternion.<>mult(com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rstore>) where { this -> RMesh : *, R -> RMesh, Rv -> RTemps, Rstore -> RTemps }, com.jme.math.Quaternion.<>mult(com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rstore>) where { this -> RctMesh : *, R -> RctMesh, Rv -> RTemps, Rstore -> RTemps }, com.jme.math.Vector3f.<>addLocal(com.jme.math.Vector3f<Rvec>) where { this -> RTemps : *, R -> RTemps, Rvec -> RMesh }, com.jme.math.Vector3f.<>addLocal(com.jme.math.Vector3f<Rvec>) where { this -> RTemps : *, R -> RTemps, Rvec -> RctMesh }, com.jme.math.Vector3f.<>multLocal(com.jme.math.Vector3f<Rvec>) where { this -> RTemps : *, R -> RTemps, Rvec -> RMesh }, com.jme.math.Vector3f.<>multLocal(com.jme.math.Vector3f<Rvec>) where { this -> RTemps : *, R -> RTemps, Rvec -> RctMesh }, com.jme.math.Vector3f.<>set(com.jme.math.Vector3f<Rvect>) where { this -> RTemps : *, R -> RTemps, Rvect -> RTemps }, com.jme.scene.TriMesh.<>getTriangle(int,com.jme.math.Vector3f<R>[]<R>) where { this -> RMesh : *, RMesh -> RMesh, R -> RTemps }, com.jme.scene.TriMesh.<>getTriangle(int,com.jme.math.Vector3f<R>[]<R>) where { this -> RctMesh : *, RMesh -> RctMesh, R -> RTemps }, com.jme.scene.TriMesh.getWorldRotation() where { this -> RMesh : *, RMesh -> RMesh }, com.jme.scene.TriMesh.getWorldRotation() where { this -> RctMesh : *, RMesh -> RctMesh }, com.jme.scene.TriMesh.getWorldScale() where { this -> RMesh : *, RMesh -> RMesh }, com.jme.scene.TriMesh.getWorldScale() where { this -> RctMesh : *, RMesh -> RctMesh }, com.jme.scene.TriMesh.getWorldTranslation() where { this -> RMesh : *, RMesh -> RMesh }, com.jme.scene.TriMesh.getWorldTranslation() where { this -> RctMesh : *, RMesh -> RctMesh }, com.jme.util.ParallelArrayList.<>addAll(com.jme.util.ParallelArrayList<Rb>) where { this -> RLists : *, R -> RLists, Rb -> Local : * }, com.jme.util.ParallelArrayList.add(int) where { this -> RLists : *, R -> RLists }
com.jme.bounding.CollisionTree.<>intersectsBounding_r(com.jme.bounding.BoundingVolume<R1>,com.jme.bounding.BoundingVolume<R2>) invokes com.jme.bounding.BoundingVolume.<>intersectsBoundingBox(com.jme.bounding.BoundingBox<Rbb>) where { this -> R1 : *, R -> R1, Rbb -> R2 }
com.jme.bounding.CollisionTree.CollisionTree() invokes java.lang.Object.Object()
com.jme.bounding.CollisionTree.CollisionTree(com.jme.bounding.CollisionTree<Root : *,RMesh>) reads Root : * writes R, R : com.jme.bounding.CollisionTree.Left, R : com.jme.bounding.CollisionTree.Right, RMesh invokes java.lang.Object.Object()
com.jme.bounding.CollisionTree.construct(com.jme.scene.TriMesh<RMesh>,boolean) writes RMesh invokes com.jme.bounding.CollisionTree.createTree(int,int,boolean) where { R -> R, RMesh -> RMesh }, com.jme.scene.TriMesh.<>getTriangleIndices(int[]<Rindices>) where { this -> RMesh : *, RMesh -> RMesh, Rindices -> RMesh }
com.jme.bounding.CollisionTree.createBounds() writes R
com.jme.bounding.CollisionTree.createTree(int,int,boolean) writes R, R : com.jme.bounding.CollisionTree.Left, R : com.jme.bounding.CollisionTree.Right, RMesh invokes com.jme.bounding.BoundingVolume.<>computeFromTris(int[]<Rindices>,com.jme.scene.TriMesh<Rindices>,int,int) where { this -> R : *, R -> R, Rindices -> RMesh }, com.jme.bounding.CollisionTree.createBounds() where { R -> R, RMesh -> RMesh }, com.jme.bounding.CollisionTree.createTree(int,int,boolean) where { this -> R : com.jme.bounding.CollisionTree.Left : *, R -> R : com.jme.bounding.CollisionTree.Left, RMesh -> RMesh }, com.jme.bounding.CollisionTree.createTree(int,int,boolean) where { this -> R : com.jme.bounding.CollisionTree.Right : *, R -> R : com.jme.bounding.CollisionTree.Right, RMesh -> RMesh }, java.io.PrintStream.println(java.lang.String) where { this -> Root : * }
com.jme.intersection.Intersection.<>coplanarTriTri(com.jme.math.Vector3f<Rn>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>) writes Rn invokes com.jme.intersection.Intersection.<>edgeAgainstTriEdges(float[]<R>,float[]<R>,float[]<R>,float[]<R>,float[]<R>,int,int) where { this -> Root : *, R -> Rn }, com.jme.intersection.Intersection.<>pointInTri(float[]<R>,float[]<R>,float[]<R>,float[]<R>,int,int) where { this -> Root : *, R -> Rn }, com.jme.math.Vector3f.<>toArray(float[]<Rfloats>) where { this -> Rv : *, R -> Rv, Rfloats -> Rn }, java.lang.Math.abs(float) where { this -> Root : * }
com.jme.intersection.Intersection.<>edgeAgainstTriEdges(float[]<R>,float[]<R>,float[]<R>,float[]<R>,float[]<R>,int,int) reads R invokes com.jme.intersection.Intersection.<>edgeEdgeTest(float[]<R>,float[]<R>,float[]<R>,int,int,float,float) where { this -> Root : *, R -> R }
com.jme.intersection.Intersection.<>edgeEdgeTest(float[]<R>,float[]<R>,float[]<R>,int,int,float,float) reads R
com.jme.intersection.Intersection.<>intersection_r(com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>) invokes com.jme.intersection.Intersection.<>intersection_r(com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,float[]<RTemps>,float[]<RTemps>) where { this -> Root : *, RVals -> RVals, RTemps -> Local : * }
com.jme.intersection.Intersection.<>intersection_r(com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RVals>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,com.jme.math.Vector3f<RTemps>,float[]<RTemps>,float[]<RTemps>) reads RVals writes RTemps invokes com.jme.intersection.Intersection.<>coplanarTriTri(com.jme.math.Vector3f<Rn>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rv>) where { this -> Root : *, Rn -> RTemps, Rv -> RVals }, com.jme.intersection.Intersection.<>newComputeIntervals(float,float,float,float,float,float,float,float,com.jme.math.Vector3f<Rabc>,com.jme.math.Vector2f<Rx>) where { this -> Root : *, Rabc -> RTemps, Rx -> RTemps }, com.jme.intersection.Intersection.<>sort(float[]<RTemps>) where { this -> Root : *, RTemps -> RTemps }, com.jme.math.Vector3f.<>cross(com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rresult>) where { this -> RTemps : *, R -> RTemps, Rv -> RTemps, Rresult -> RTemps }, com.jme.math.Vector3f.<>dot(com.jme.math.Vector3f<Rvec>) where { this -> RTemps : *, R -> RTemps, Rvec -> RVals }, com.jme.math.Vector3f.<>subtract(com.jme.math.Vector3f<Rvec>,com.jme.math.Vector3f<Rresult>) where { this -> RVals : *, R -> RVals, Rvec -> RVals, Rresult -> RTemps }, java.lang.Math.abs(float) where { this -> Root : * }
com.jme.intersection.Intersection.<>newComputeIntervals(float,float,float,float,float,float,float,float,com.jme.math.Vector3f<Rabc>,com.jme.math.Vector2f<Rx>) writes Rabc, Rx
com.jme.intersection.Intersection.<>pointInTri(float[]<R>,float[]<R>,float[]<R>,float[]<R>,int,int) reads R
com.jme.intersection.Intersection.<>sort(float[]<RTemps>) writes RTemps
com.jme.intersection.Intersection.Intersection() invokes java.lang.Object.Object()
com.jme.math.Matrix3f.<>mult(com.jme.math.Vector3f<Rvec>,com.jme.math.Vector3f<Rproduct>) reads R, Rvec writes Rproduct
com.jme.math.Matrix3f.<>set(com.jme.math.Quaternion<Rquaternion>) invokes com.jme.math.Quaternion.<>toRotationMatrix(com.jme.math.Matrix3f<Rresult>) where { this -> Rquaternion : *, R -> Rquaternion, Rresult -> R }
com.jme.math.Matrix3f.Matrix3f() invokes java.lang.Object.Object()
com.jme.math.Quaternion.<>mult(com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rstore>) reads R, Rv writes Rstore invokes com.jme.math.Vector3f.set(float,float,float) where { this -> Rstore : *, R -> Rstore }
com.jme.math.Quaternion.<>toRotationMatrix(com.jme.math.Matrix3f<Rresult>) reads R writes Rresult invokes com.jme.math.Quaternion.norm() where { R -> R }
com.jme.math.Quaternion.Quaternion() writes R invokes java.lang.Object.Object()
com.jme.math.Quaternion.norm() reads R
com.jme.math.Quaternion.readExternal(java.io.ObjectInput) writes R invokes java.io.DataInput.readFloat() where { this -> Root : * } overrides java.io.Externalizable.readExternal(java.io.ObjectInput)
com.jme.math.Quaternion.writeExternal(java.io.ObjectOutput) reads R invokes java.io.DataOutput.writeFloat(float) where { this -> Root : * } overrides java.io.Externalizable.writeExternal(java.io.ObjectOutput)
com.jme.math.Vector2f.Vector2f() writes R invokes java.lang.Object.Object()
com.jme.math.Vector2f.readExternal(java.io.ObjectInput) writes R invokes java.io.DataInput.readFloat() where { this -> Root : * } overrides java.io.Externalizable.readExternal(java.io.ObjectInput)
com.jme.math.Vector2f.writeExternal(java.io.ObjectOutput) reads R invokes java.io.DataOutput.writeFloat(float) where { this -> Root : * } overrides java.io.Externalizable.writeExternal(java.io.ObjectOutput)
com.jme.math.Vector3f.<>addLocal(com.jme.math.Vector3f<Rvec>) reads Rvec writes R
com.jme.math.Vector3f.<>cross(com.jme.math.Vector3f<Rv>,com.jme.math.Vector3f<Rresult>) reads Rv invokes com.jme.math.Vector3f.<>cross(float,float,float,com.jme.math.Vector3f<Rresult>) where { R -> R, Rresult -> Rresult }
com.jme.math.Vector3f.<>cross(float,float,float,com.jme.math.Vector3f<Rresult>) reads R invokes com.jme.math.Vector3f.set(float,float,float) where { this -> Rresult : *, R -> Rresult }
com.jme.math.Vector3f.<>dot(com.jme.math.Vector3f<Rvec>) reads R, Rvec
com.jme.math.Vector3f.<>isValidVector(com.jme.math.Vector3f<Rvector>) reads Rvector invokes java.lang.Float.isInfinite(float) where { this -> Root : * }, java.lang.Float.isNaN(float) where { this -> Root : * }
com.jme.math.Vector3f.<>mult(com.jme.math.Vector3f<Rvec>,com.jme.math.Vector3f<Rstore>) reads R, Rvec invokes com.jme.math.Vector3f.set(float,float,float) where { this -> Rstore : *, R -> Rstore }
com.jme.math.Vector3f.<>multLocal(com.jme.math.Vector3f<Rvec>) reads Rvec writes R
com.jme.math.Vector3f.<>set(com.jme.math.Vector3f<Rvect>) reads Rvect writes R
com.jme.math.Vector3f.<>subtract(com.jme.math.Vector3f<Rvec>,com.jme.math.Vector3f<Rresult>) reads R, Rvec writes Rresult
com.jme.math.Vector3f.<>toArray(float[]<Rfloats>) reads R writes Rfloats
com.jme.math.Vector3f.Vector3f() writes R invokes java.lang.Object.Object()
com.jme.math.Vector3f.Vector3f(float,float,float) writes R invokes java.lang.Object.Object()
com.jme.math.Vector3f.multLocal(float) writes R
com.jme.math.Vector3f.readExternal(java.io.ObjectInput) writes R invokes java.io.DataInput.readFloat() where { this -> Root : * } overrides java.io.Externalizable.readExternal(java.io.ObjectInput)
com.jme.math.Vector3f.set(float,float,float) writes R
com.jme.math.Vector3f.writeExternal(java.io.ObjectOutput) reads R invokes java.io.DataOutput.writeFloat(float) where { this -> Root : * } overrides java.io.Externalizable.writeExternal(java.io.ObjectOutput)
com.jme.scene.TriMesh.<>getTriangle(int,com.jme.math.Vector3f<R>[]<R>) reads RMesh writes R invokes com.jme.scene.TriMesh.getTriangleCount() where { RMesh -> RMesh }
com.jme.scene.TriMesh.<>getTriangleIndices(int[]<Rindices>) writes Rindices invokes com.jme.scene.TriMesh.getTriangleCount() where { RMesh -> RMesh }
com.jme.scene.TriMesh.TriMesh() invokes java.lang.Object.Object()
com.jme.scene.TriMesh.getTriangleCount() reads RMesh
com.jme.scene.TriMesh.getWorldRotation() reads RMesh
com.jme.scene.TriMesh.getWorldScale() reads RMesh
com.jme.scene.TriMesh.getWorldTranslation() reads RMesh
com.jme.scene.TriMesh.readExternal(java.io.ObjectInput) writes RMesh invokes java.io.ObjectInput.readObject() where { this -> Root : * } overrides java.io.Externalizable.readExternal(java.io.ObjectInput)
com.jme.scene.TriMesh.writeExternal(java.io.ObjectOutput) reads RMesh invokes java.io.ObjectOutput.writeObject(java.lang.Object) where { this -> Root : * } overrides java.io.Externalizable.writeExternal(java.io.ObjectOutput)
com.jme.scene.shape.Sphere.Sphere() invokes com.jme.scene.TriMesh.TriMesh() where { RMesh -> Root }
com.jme.util.ParallelArrayList.<>addAll(com.jme.util.ParallelArrayList<Rb>) reads R, Rb invokes java.util.ArrayList.addAll(java.util.Collection<? extends E>) where { this -> Root : * }
com.jme.util.ParallelArrayList.ParallelArrayList() writes R invokes java.lang.Object.Object()
com.jme.util.ParallelArrayList.ParallelArrayList(int) writes R invokes java.lang.Object.Object()
com.jme.util.ParallelArrayList.add(int) reads R invokes java.util.ArrayList.add(E) where { this -> Root : * }
com.jmex.effects.cloth.CollidingClothPatch.CollidingClothPatch() invokes com.jme.scene.TriMesh.TriMesh() where { RMesh -> Root }
jmetest.collisiontree.BenchmarkCollisionTree.BenchmarkCollisionTree() invokes java.lang.Object.Object()
jmetest.collisiontree.BenchmarkCollisionTree.main(java.lang.String[]) reads Root invokes com.jme.bounding.CollisionTree.<>intersect(com.jme.bounding.CollisionTree<R_cT,R_cT>,com.jme.util.ParallelArrayList<RLists>,com.jme.util.ParallelArrayList<RLists>,int) where { this -> Local : *, R -> Local : *, RMesh -> Local : *, R_cT -> Local : *, RLists -> Local : * }, com.jme.bounding.CollisionTree.construct(com.jme.scene.TriMesh<RMesh>,boolean) where { this -> Local : *, R -> Local : *, RMesh -> Local : * }, java.io.ObjectInputStream.readUnshared() where { this -> Root : * }, java.io.PrintStream.println(java.lang.String) where { this -> Root : * }, java.lang.Integer.parseInt(java.lang.String) where { this -> Root : * }, java.lang.System.exit(int) where { this -> Root : * }, java.lang.System.nanoTime() where { this -> Root : * }, java.lang.Throwable.printStackTrace() where { this -> Root : * }, java.util.ArrayList.size() where { this -> Root : * }
